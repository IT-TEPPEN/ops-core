package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/jackc/pgx/v5/pgxpool"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"

	_ "opscore/backend/docs" // docs is generated by Swag CLI
)

// @title OpsCore Backend API
// @version 1.0
// @description This is the API documentation for the OpsCore backend service.
// @host localhost:8080
// @BasePath /api/v1
func main() {
	// --- Database Connection ---
	// Use environment variable for connection string (replace with your actual env var name)
	databaseUrl := os.Getenv("DATABASE_URL")
	if databaseUrl == "" {
		// Provide a default for local development if needed, but env var is better
		databaseUrl = "postgres://opscore_user:opscore_password@db:5432/opscore_db?sslmode=disable"
		fmt.Println("Warning: DATABASE_URL environment variable not set, using default.")
	}

	dbpool, err := pgxpool.New(context.Background(), databaseUrl)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Unable to create connection pool: %v\n", err)
		os.Exit(1) // Exit if DB connection fails
	}
	defer dbpool.Close() // Ensure pool is closed when main function exits

	// Ping the database to verify connection
	err = dbpool.Ping(context.Background())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Unable to ping database: %v\n", err)
		os.Exit(1)
	}
	fmt.Println("Successfully connected to the database.")
	// --- End Database Connection ---

	// Initialize dependencies using Wire, passing the db pool
	repoHandler, docHandler, varHandler, err := InitializeAPI(dbpool) // Pass dbpool and handle error
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to initialize API dependencies: %v\n", err)
		os.Exit(1)
	}

	r := gin.Default()

	// Allow all origins (for development)
	r.Use(func(c *gin.Context) {
		c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
		c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
		c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
		c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE")

		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(204)
			return
		}

		c.Next()
	})

	// Swagger documentation endpoint
	// Adjust the import path above before running swag init
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// API v1 routes group
	v1 := r.Group("/api/v1")
	{
		// Repository routes - use methods from the initialized handler
		v1.POST("/repositories", repoHandler.RegisterRepository)
		v1.GET("/repositories", repoHandler.ListRepositories)      // Adding this route to list all repositories
		v1.GET("/repositories/:repoId", repoHandler.GetRepository) // New route to get repository details by ID
		v1.GET("/repositories/:repoId/files", repoHandler.ListRepositoryFiles)
		v1.POST("/repositories/:repoId/files/select", repoHandler.SelectRepositoryFiles)
		v1.GET("/repositories/:repoId/markdown", repoHandler.GetSelectedMarkdown)
		v1.PUT("/repositories/:repoId/token", repoHandler.UpdateAccessToken) // アクセストークン更新用エンドポイント

		// Document routes
		v1.POST("/documents", docHandler.CreateDocument)
		v1.GET("/documents", docHandler.ListDocuments)
		v1.GET("/documents/:docId", docHandler.GetDocument)
		v1.PUT("/documents/:docId", docHandler.UpdateDocument)
		v1.PATCH("/documents/:docId/metadata", docHandler.UpdateDocumentMetadata)
		v1.GET("/documents/:docId/versions", docHandler.GetDocumentVersions)
		v1.GET("/documents/:docId/versions/:version", docHandler.GetDocumentVersion)
		v1.POST("/documents/:docId/versions/:version/publish", docHandler.PublishDocumentVersion)
		v1.POST("/documents/:docId/versions/:version/rollback", docHandler.RollbackDocumentVersion)

		// Variable routes
		v1.GET("/documents/:docId/variables", varHandler.GetVariableDefinitions)
		v1.POST("/documents/:docId/validate-variables", varHandler.ValidateVariableValues)
	}

	// Static file serving (Frontend)
	r.StaticFile("/", "./frontend/dist/index.html")
	r.Static("/assets", "./frontend/dist/assets")
	r.StaticFile("/favicon.ico", "./frontend/dist/favicon.ico")
	r.StaticFile("/vite.svg", "./frontend/dist/vite.svg")
	r.NoRoute(func(c *gin.Context) {
		if !strings.HasPrefix(c.Request.URL.Path, "/api") {
			filePath := "./frontend/dist" + c.Request.URL.Path
			absPath, _ := filepath.Abs(filePath)
			if _, err := http.Dir(filepath.Dir(absPath)).Open(filepath.Base(absPath)); err != nil {
				c.File("./frontend/dist/index.html")
				return
			}
			c.File(filePath)
		} else {
			c.JSON(http.StatusNotFound, gin.H{"code": "PAGE_NOT_FOUND", "message": "Page not found"})
		}
	})

	port := "8080"
	println("Backend server listening at http://localhost:" + port)
	r.Run(":" + port)
}
